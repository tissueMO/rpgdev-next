<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>RPG Developer NEXT 取扱説明書</title>
<link rel="stylesheet" type="text/css" href="css/reset.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="js/jquery.min.js"></script>
<script src="js/script.js"></script>
<script src="js/auto-document.js"></script>
<script src="js/version-getter.js"></script>
</head>

<body class="node_sq">
<!-- タイトルバー -->
<div id="header">
  <a href="index.html"><h1><span>RPG Developer NEXT</span> <script>PrintVersion();</script> 取扱説明書</h1></a>
</div>

<div id="container">
<!-- 目次サイドバー -->
<div id="menuContainer">
  <div id="menuContent">
    <script src="js/manual-tree.js"></script>
    <script src="js/auto-tree.js"></script>
  </div>
</div>

<!-- メインコンテンツ -->
<div id="mainContainer">
  <!-- ぱんくずリスト [&gt]=[>] -->
  <div id="breadcrumb"><a href="index.html">HOME</a> &gt; スクリプト言語「Squirrel」</div>

  <!-- 親ノード見出し -->
  <h2>スクリプト言語「Squirrel 2.2.4」</h2>
  <div class="text">
    <!-- 親ノードのテキスト -->
    <p>
      本ソフトの中核を担う部分であり、捉え方によっては最も高いハードルとして感じてしまうかもしれない機能です。<br>
      ゲームの製作者はゲーム上の処理をすべてスクリプトに記述していきます。<br>
      拡張性や移植性等、様々な面を考慮した結果、Squirrelという言語を選択するに至りました。<br>
    </p>
    <p>
      なお、本ソフト内ではSquirrelスクリプトのことを略称「SQ」と呼んでいます。<br>
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="1">基本概念</h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <h4>スクリプト言語としての予備知識</h4>
    <p>
      Squirrelの発音は日本人にはなかなか難しいですが、「スクワール」とよく呼ばれているようです。<br>
      組み込みスクリプトと呼ばれるものの一種で、メジャーなものでは他に「Lua」というものがあります。<br>
      実はLuaの方が圧倒的にメジャーなのですが、構文が独特である等、不便な部分も多々あったようです。<br>
      Squirrelはまさにそんな不満を払拭すべくして開発された言語で、文法がC++やJavaに近いものであったり、配列やクラス等の機能を標準でサポートしていたり等の様々な改良がなされています。<br>
      実行速度はLuaと比較するとやや見劣りします。<br>
    </p>
    <p>
      Squirrel言語の主な実績として、以下のような作品がリリースされています。<br>
    </p>
    <ul class="disc">
      <li>小さな王様と約束の国 ファイナルファンタジー・クリスタルクロニクル (2008・Wii)</li>
      <li>光と闇の姫君と世界征服の塔 ファイナルファンタジー・クリスタルクロニクル (2009・Wii)</li>
      <li>X-Blades (2009・PS3)</li>
      <li>東方心綺楼 (2013・Windows)</li>
    </ul>

    <h4>プログラムとスクリプトの違い</h4>
    <p>
      前者はそれ単体で動作できるマシンコード（機械語）のことで、後者は人間もそのまま読むことができ、ランタイムと呼ばれる環境下で動作するコードとして大別されます。<br>
      プログラムにはさらに大きく分けてコンパイラー型とインタプリター型に分かれますが、実行速度の都合で多くはコンパイラー型です。<br>
      プログラムの規模が大きくなると、コンパイルに多くの時間がかかるようになる上に、一般的には実行中に修正して反映させる、というようなこともできません。<br>
      一方でスクリプトは、こういった問題を解決できるものが多く、プログラムの実行中に読み込まれ、動的に再読み込みを行うこともできます。<br>
      ゲーム開発では実行中に難易度や表示位置等の微調整をする機会が非常に多くあるため、この恩恵を存分に得られることになります。<br>
    </p>

    <h4>動的型付け</h4>
    <p>
      ある値を格納する入れ物のことを「変数」と呼びますが、この変数には本来「型」というものがあります。<br>
      値の型は主に、整数型、小数型、論理型、文字列型が挙げられます。<br>
      しかし、同言語を含む多くのスクリプト言語では、このような型を意識せずに済むような設計になっています。<br>
      このような設計のことを「動的型付け」と呼び、Squirrelでは代入する値の型に合わせて代入先の変数の型が動的に変化します。<br>
    </p>

    <h4>内部型</h4>
    <p>
      動的型付けを行う言語ではありますが、内部的には明確に区別されています。<br>
      組み込みオブジェクトのリファレンスには内部型を含めていますので、ここではその型について以下に示します。<br>
      なお、下記以外の型には関数定義、クラス定義、インスタンスへの参照等があります。<br>
    </p>
    <table>
      <tr>
        <th width="150">int</th>
        <td width="500">整数型</td>
      </tr>
      <tr>
        <th>float / double</th>
        <td>小数型</td>
      </tr>
      <tr>
        <th>bool</th>
        <td>論理型 (true / false)</td>
      </tr>
      <tr>
        <th>string / TCHAR*</th>
        <td>文字列型</td>
      </tr>
      <tr>
        <th>void</th>
        <td>型無し（関数の場合は戻り値がないことを示す）</td>
      </tr>
    </table>

    <h4>コンパイル</h4>
    <p>
      内部的な処理の説明になりますが、ゲームプログラムはSquirrelのVM(仮想マシン)を介してスクリプトを読み込み、バイトコードに変換します。<br>
      この一連の作業中に、バイトコードに変換できないような不備が見つかった場合はコンパイルエラーとなります。<br>
      コンパイルエラーは比較的軽微な不備に分類されるため、エラー内容に従ってその場でコードを修正し、すぐに再開することができます。<br>
    </p>

    <h4>実行</h4>
    <p>
      スクリプトをロードすると、関数定義やクラス定義の外側にあるグローバルスコープのコードが実行されます。<br>
      ここには通常、変数や関数の宣言・定義等を行います。<br>
      これらの定義が行われた後は、自由に変数や関数を呼び出すことができるようになります。<br>
    </p>
    <p>
      コードの実行中に問題が発生したときは、ランタイムエラーとなります。<br>
      ランタイムエラーはプログラムの続行に支障をきたす問題なので、エラー内容を表示しつつも、プログラムの終了を余儀なくされます。<br>
      なお、システムDBの「制限付きデバッグモード」が無効化されているときは、エラー箇所を無視して続行したり任意のコードを実行したりできるようになります。<br>
      万が一これらの操作に失敗すると、異常終了を引き起こして大量のメモリリークをもたらす危険性があるため、搭載メモリに余裕がありそのリスクを承知している場合のみ実行することをお勧めします。<br>
    </p>

    <h4>クラッシュ</h4>
    <p>
      不慣れなプログラマーは予期せぬコードを書くことがありますし、一方で上級者はリスクをはらむ実験的なコードを書くこともあります。<br>
      スクリプト上では問題なく動作したとしても、ゲームプログラム上で処理できない重大な問題が起こる可能性もあります。<br>
      ゲームプログラム上で問題が起きたことを検知できた場合は「内部エラー」となり、エラーログを出力した上でプログラムの終了を余儀なくされます。<br>
    </p>
    <p>
      しかし、ゲームプログラム上の不備で問題を検知できなかった場合、「クラッシュ」を引き起こして、Windows Vista 以降のOSでは「～は動作を停止しました」旨の表示が出ることがあります。<br>
      このようなケースは異常終了であるため、ログの出力やエラー箇所は一切表示されませんが、スクリプト上のどこかに問題があることが多いです。<br>
      なお、クラッシュした場合は動的に確保されたメモリが解放されずに残り続けることになるため、何度も繰り返しクラッシュするとプログラムが正常に起動できなくなり、コンピューターの再起動が必要になることもありえます。<br>
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="2"><a href="sq-syntax.html">基本文法</a></h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <p>
      基本的には C++ や Java 等と大差ない構文です。<br>
      ただし、動的型付けを行う都合で新しい構文が作られていますので、C++/Java経験者の方も念のため上記リンクでご確認下さい。
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="3">注意すべき点</h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <ul class="disc">
      <li>スクリプトそのものは動的型付けを行いますが、「組み込みオブジェクト」は静的型付けを行うゲームプログラムに依存します。</li>
      <li>構文が間違っている場合は、コンパイルエラー（修正を待ってから再開する）となります。</li>
      <li>関数に与えた引数が足りない、もしくは多すぎるときはランタイムエラー（プログラムの終了を余儀なくさせる）となります。</li>
      <li>関数に与えた引数の型が不正な場合はランタイムエラーとなります。ただし、インスタンス型は厳密にはチェックできません。</li>
      <li>ランタイムエラー時に任意のコードを実行するとき、エラー箇所で定義されているローカル変数は参照できません。</li>
      <li>ランタイムエラー時に無視して続行したとき、同一の行が実行されることがあります。その場合は致命的なエラーなので異常終了する可能性があります。</li>
      <li>インスタンスのメンバーにない変数や関数、プロパティを呼び出すとランタイムエラーとなります。</li>
      <li>組み込みオブジェクトの変数や関数、プロパティに不正なインスタンス型を与えるとクラッシュしてしまうので、解説をよく読んで十分ご注意下さい。</li>
      <li>簡単に言えば、正しくない記述をすると コンパイルエラー・ランタイムエラー・クラッシュ（内部エラー） のいずれかの結果を招くということになります。</li>
    </ul>

    <h4>サブルーチンを作る場合</h4>
    <p>
      スクリプトは通常、イベントコマンドの実行内容もしくはメインルーチン（メインループ）の描画や入力処理の中で呼び出されます。<br>
      これはすなわち、メインルーチン（メインループ）の1フレーム内の処理で完結することを意味します。<br>
      例えば、DXライブラリ関数の描画系統や、各種入力情報はわずか1フレーム内でしか有効となりません。<br>
    </p>
    <p>
      しかし、スクリプトの中でも入れ子的に描画や入力処理を行いたい場合があります。<br>
      そのようなときは以下のように記述します。<br>
    </p>

    <p>
      描画処理を行うサブルーチン:<br>
    </p>
    <pre><code>
<strong class="comment">// Wait関数の第2引数を false にすると、毎フレームのシーン描画が停止して「トランジション準備」と同じ状態になります。</strong>
<strong class="keyword">while</strong>(Game.Wait(0, <strong class="keyword">true</strong>, <strong class="keyword">true</strong>)) {

  <strong class="comment">// TODO: DXライブラリ関数を使った描画処理</strong>
  <strong class="comment">// TODO: 終了条件を満たしていたらループを脱出する処理</strong>

  Game.FPSKeeper.Update();    <strong class="comment">// 描画内容を画面に反映させます。</strong>
}
    </code></pre>

    <p>
      入力処理を行うサブルーチン:<br>
    </p>
    <pre><code>
<strong class="comment">// 入力情報を更新するには、Wait関数の第3引数を true にする必要があります。</strong>
<strong class="keyword">while</strong>(Game.Wait(0, <strong class="keyword">true</strong>, <strong class="keyword">true</strong>)) {
  <strong class="comment">// TODO: 入力情報を用いた処理等</strong>
  <strong class="comment">// TODO: 終了条件を満たしていたらループを脱出する処理</strong>
}
    </code></pre>

    <p>
      上記のループ条件に使っているWait関数は、ウェイト秒数をゼロとすることでウェイト処理を行うことなくサブルーチンの維持に最低限必要な処理のみを行ってくれます。<br>
      サブルーチンの維持に最低限必要な処理とは、Windowsのメッセージ処理や入力処理、並列処理、画面更新等を指します。<br>
      これらの処理を行わずに数フレームに渡るようなループを作った場合、フリーズしたような状態（いわゆる「応答なし」状態）となってしまいますのでご注意下さい。<br>
    </p>

  </div>
  <hr>

</div><!-- /#mainContainer -->
</div><!-- /#container -->
</body>
</html>
