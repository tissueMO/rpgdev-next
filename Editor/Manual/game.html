<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>RPG Developer NEXT 取扱説明書</title>
<link rel="stylesheet" type="text/css" href="css/reset.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="js/jquery.min.js"></script>
<script src="js/script.js"></script>
<script src="js/auto-document.js"></script>
<script src="js/version-getter.js"></script>
</head>

<body class="node_game">
<!-- タイトルバー -->
<div id="header">
  <a href="index.html"><h1><span>RPG Developer NEXT</span> <script>PrintVersion();</script> 取扱説明書</h1></a>
</div>

<div id="container">
<!-- 目次サイドバー -->
<div id="menuContainer">
  <div id="menuContent">
    <script src="js/manual-tree.js"></script>
    <script src="js/auto-tree.js"></script>
  </div>
</div>

<!-- メインコンテンツ -->
<div id="mainContainer">
  <!-- ぱんくずリスト [&gt]=[>] -->
  <div id="breadcrumb"><a href="index.html">HOME</a> &gt; ゲームプログラム部</div>

  <!-- 親ノード見出し -->
  <h2>ゲームプログラム部</h2>
  <div class="text">
    <!-- 親ノードのテキスト -->
    <p>
      エディターによって作成されるゲームの本体プログラムです。<br>
      こちらを起動することで、製作したゲームを実際に遊ぶことができます。<br>
      ゲームプログラムは C++/ネイティブ で開発されているため、比較的高速に動作します。<br>
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="1"><a href="game-knowledge.html">基本概念</a></h3>
  <div class="text">
    <p>
      ゲームプログラムの根幹をなすシステムについて解説しています。<br>
      スクリプトの組み込みオブジェクトはこの部分を操作するものなので、コーディングする場合はきちんと理解している必要があります。<br>
      詳細は上記リンクからご覧下さい。<br>
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="2">スクリプトとの連携</h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <p>
      スクリプトの処理が実行されるタイミングは、あくまでもゲームプログラム側からの呼び出しを受けたときに限られます。<br>
    </p>

    <h4>イベントハンドラー</h4>
    <p>
      プレイヤーやシステムからの操作を受けてそれに従った処理を行う、いわゆる「イベント駆動」方式による実行です。<br>
      本ソフトではこの概念を拡張し、ゲームプログラム側が一部の処理を委託するために呼び出すスクリプト関数のことを総称して「イベントハンドラー」と呼んでいます。<br>
      委託するのは処理の一部にすぎず、これはゲームプログラム側で予約された関数名で呼び出されます。<br>
      シーンの描画や入力等の自由度の広いものから、デバッグコマンドの定義等の限定的な処理まで様々なものがあります。<br>
    </p>

    <h4>スクリプトの動的読み込み</h4>
    <p>
      ゲームプログラムがスクリプトを読み込むタイミングは主としてシーンを遷移するときですが、これらは予約された名前のファイルです。<br>
      読み込む際にグローバルスコープのコードが実行されるため、ここでさらに別のスクリプトの読み込み処理を挟むことで任意のスクリプトを読み込むことができます。<br>
      デバッグ中に動的リロードを行うときはシーンスクリプトが対象となります。<br>
      よって、それに含まれる外部スクリプトも一緒にリロードされるという仕組みになっています。<br>
    </p>
    <p>
      ただし、変数の定義や初期化において、処理の内容だけを更新するようにして変数の値はそのままにしておきたいことがあります。<br>
      そこで、ファイル名の先頭に ! が付与されているスクリプトはデバッグ中の動的リロードの対象外とする仕様にしています。<br>
      変数の定義や初期化を行うファイルについてはファイル名の先頭に ! を付けることをお勧めします。<br>
    </p>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="3">ゲーム操作方法</h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <p>
      ここではゲームプログラム側によって予約された操作キーを紹介します。<br>
      基本的に入力操作はすべてスクリプトに委託しているので、システムによって予約されている操作はそれほど多くありません。<br>
    </p>

    <h4>一般的な操作</h4>
    <table>
      <tr>
        <th width="100">F11</th>
        <td width="600">
          ゲームのポーズ状態を切り替えます。ポーズ中はゲームの動作が停止します。<br>
          ただし、イベント実行時やスクリプトの動作中には操作を受け付けない場合があります。<br>
        </td>
      </tr>
      <tr>
        <th>Esc</th>
        <td>ゲームを終了します。終了確認が行われます。</td>
      </tr>
      <tr>
        <th>PrintScreen</th>
        <td>
          ゲームのスクリーンショットを撮影します。<br>
          撮影した画像は ScreenShots フォルダーに保存されます。<br>
        </td>
      </tr>
    </table>

    <h4>デバッグモード限定の操作</h4>
    <p>
      デバッグ時は上記の操作に加えて次のような操作ができます。<br>
    </p>
    <table>
      <tr>
        <th width="100">F3</th>
        <td width="600">マップシーンのみ：現在のマップに入り直します。</td>
      </tr>
      <tr>
        <th>F4</th>
        <td>
          現在のシーンスクリプトを再コンパイルします。<br>
          その中で読み込まれるサブスクリプトも再コンパイル対象となります。<br>
        </td>
      </tr>
      <tr>
        <th>F5</th>
        <td>スクリプトデバッガーを起動して、コンソール画面をアクティブにします。</td>
      </tr>
      <tr>
        <th>F8</th>
        <td>画面左上に表示されるシステムリソースパネルの切り替えを行います。</td>
      </tr>
    </table>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="4">デバッグ</h3>
  <div class="text">
    <p>
      本ソフトにおける「デバッグ」と「テスト」はほとんど同じ意味を指します。<br>
      デバッグモードのときにF5キーで呼び出せるスクリプトデバッガー（コンソール）上で操作を行います。<br>
      以下のような強力なデバッグツールを駆使して、ゲームを動作させながら修正していくトライ＆エラーのスタイルが有効です。<br>
    </p>

    <!-- 子ノードのテキスト -->
    <h4>デバッグコマンド</h4>
    <p>
      ゲームの動作を一時停止して特定の操作や確認をするときは、このデバッグコマンドというものを入力します。<br>
      入力の書式は、[コマンド名 引数1 引数2 ...] と、それぞれ空白スペースで区切って入力します。<br>
      コマンドは様々なものがあり、すべてを覚えきることは困難ですので h と打ってヘルプをご覧になることをお勧めします。<br>
      なお、デバッグコマンド上で引数に指定する「ID」は FixedID ではなく製作者自身が設定した「ID」の受け入れを想定しているものがあります。<br>
    </p>

    <!-- 子ノード見出し -->
    <h4>即席コード</h4>
    <p>
      ゲームの動作を一時停止している間に、任意のスクリプトコードを実行させることができます。<br>
      主にスクリプト内で定義されたグローバル変数の値を確認したり、オブジェクトの中身を確認したりする程度を想定していますが、任意の一連の操作をまとめて実行させることもできます。<br>
      ただし、この処理中にランタイムエラーが起きるとゲームプログラム自体が終了してしまいます。タイプミス等にはくれぐれもご注意下さい。<br>
    </p>

    <!-- 子ノード見出し -->
    <h4>ステップ実行</h4>
    <p>
      スクリプトの処理を1行ずつ逐次的に行いながらデバッグする手法です。<br>
      1行コードが実行されるたびにゲームの動作を一時停止して、その時点でのスタックトレース（スクリプト関数の呼出階層）やローカル変数の値を表示します。<br>
      関数に対しては以下のような操作が可能です。<br>
    </p>
    <ul class="disc">
      <li>ステップイン … 関数の呼び出し先にジャンプします。</li>
      <li>ステップオーバー … 関数を呼び出しますが、呼び出し先の内部にはジャンプしません。</li>
      <li>ステップアウト … 現在の関数で残っている処理をすべて実行します。一つ上の呼出階層に戻るまで処理は戻りません。</li>
    </ul>

    <!-- 子ノード見出し -->
    <h4>エラー発生時</h4>
    <p>
      スクリプトをコンパイルするとき、もしくはコードを実行しているときにエラーが発生した場合は、エラー箇所（スクリプトファイル名、行数、関数名）とエラー内容が出力されます。<br>
      この情報を辿っていくことでエラーの原因を探ることができるようになっています。<br>
    </p>
    <ul class="disc">
      <li>コンパイルエラー（スクリプトロード中のエラー） … ゲームの動作を一時停止して、スクリプトの修正が完了した後再読み込みすることでゲームを再開することができます。</li>
      <li>
        ランタイムエラー（スクリプト実行中のエラー）… その後の処理を正しく動作させられる保証ができないため、その時点でプログラムが終了します。<br>
        ログを出力して終了することで Logs フォルダー以下にエラー発生時点の内部データを確認することができます。<br>
      </li>
      <li>
        内部エラー（ゲームプログラム起因のエラー） … その後の処理を正しく動作させられる保証ができないため、その時点でプログラムが終了します。<br>
        ログを出力して終了することで Logs フォルダー以下にエラー発生時点の内部データを確認することができます。<br>
        多くのケースではスクリプトの修正だけで解決しますが、稀にゲームプログラム自体のバグが原因であることもありえます。<br>
      </li>
    </ul>
  </div>
  <hr>

  <!-- 子ノード見出し -->
  <h3 id="5">細かい動作仕様</h3>
  <div class="text">
    <!-- 子ノードのテキスト -->
    <h4>シーン</h4>
    <ul class="disc">
      <li>ゲームプログラム側でクラス定義しているシーンはタイトルとマップの2つのみで、これらを「メインシーン」と呼びます。</li>
      <li>シーンIDとしては他にメニュー、ショップ、バトルを定義していますが、これらは必ずメインシーンの中で動作する「サブシーン」となります。</li>
      <li>BGM/BGSはメインシーンごとに管理する都合で、シーン遷移時に再生が停止します。</li>

      <li>
        サブシーンへの移行は２通りの方法があります。いずれも入力処理はサブシーンのものが呼び出されます。
        <ul class="circle">
          <li>メインシーンの描画を維持する方法</li>
          <li>サブシーンのみ描画する方法</li>
        </ul>
      </li>

      <li>
        マップシーン
        <ul class="circle">
          <li>マップタイルのアニメーションは、パターン数が異なっていてもすべて一律のフレーム数で一周します。</li>
          <li>影はキャラクターの下半身にだけかかり、上半身にはかかりません。</li>
          <li>タイルの当たり判定について、すべてのレイヤーが空白 (0, 0) になっているタイルは歩けません。</li>
          <li>イベントのページ条件判定はイベント実行中も常時行われます。</li>
          <li>イベントのいずれのページ条件も満たさない場合、デフォルトでページ1番が有効となります。</li>
          <li>イベントからの接触で起動するイベントに対して主人公側から接触した場合も起動します。</li>
          <li>主人公からの接触で起動するイベントに対してイベント側から接触しても起動しません。</li>
          <li>スクリプト指定による日常移動のとき、障害物により進行できない場合はデフォルトで次の移動指示へ進みます。</li>
          <li>イベントの臨時移動（日常移動ではなくイベント実行時の移動）では、障害物により進行できない場合は経路固定の設定があっても次の移動指示へ進みます。</li>
          <li>イベントの接触範囲は、0x0 のときイベントの座標部分だけが接触点となります。</li>
          <li>イベントの接触範囲は、あくまでもイベントの起動に関わる接触範囲であるため、移動における当たり判定とは無関係です。</li>
          <li>キャラクターの移動カウンターを原点以外に変更すると、自動的に毎フレーム移動速度で原点位置に戻ろうとします。</li>
          <li>キャラクターの移動カウンターが自動的に原点位置に戻されたとき、自動で一致起動イベントの起動判定と実行予約が行われます。</li>
          <li>
            マップのループ
            <ul class="circle">
              <li>キャラクター移動における当たり判定はループする端点を考慮します。</li>
              <li>端点同士でオートタイルは適用されないため、端点同士は同一のタイルであることが望ましいです。</li>
              <li>主人公を追いかける日常移動は、ループする端点を考慮しないため端点を跨ぐと目の前にいたとしても反対側に向かってしまいます。</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <h4>疑似マルチスレッド</h4>
    <ul class="disc">
      <li>各スレッドには一意の識別番号を持ちます。</li>
      <li>スレッド名は重複が許可されており、スレッドに対する操作は名前が合致するものすべてに適用されます。</li>
      <li>スクリプトから追加したスレッドが存在しない関数である場合は最初の実行時に削除されます。</li>
    </ul>

    <h4>デバッグ コンソール</h4>
    <ul class="disc">
      <li>デバッグ版では常に表示されます。リリース版では非表示となります。</li>
      <li>ゲームが動作している間はコンソールに入力することはできません。</li>
      <li>コンソールに入力できる状態のときはゲームの動作は停止します。</li>
      <li>コンソールに表示される内容は一部（ステップ実行時に出力される情報や、デバッグコマンドによる操作等）を除いてはログ出力の対象となります。</li>
      <li>コンソール上で Ctrl+C キーを押すとゲームプログラム自体が終了します。</li>
    </ul>

    <h4>データベース</h4>
    <ul class="disc">
      <li>単体サブデータベースでは、列名と型名の両方を保持しており、セルにアクセスするにはインデックスか列名を使います。</li>
      <li>各セルは列の型名を保持しており、値をセットするときはその型名に応じた型に代入します。</li>
      <li>複数値型のセルが空欄のとき、0 が一つだけセットされた状態となります。</li>
      <li>必要なデータベースが存在しないときはプログラムを起動できません。</li>
      <li>データベースや単体サブデータベースの取得に失敗した場合は内部エラーとなりゲームプログラム自体が終了します。</li>
      <li>セル値の取得に失敗した場合は空白に相当する値が返されます。</li>
      <li>固定DBのセルを変更することは可能ですが、セーブ対象になりません。</li>
      <li>
        アクターDB
        <ul class="circle">
          <li>パーティキャラDBのデータを基にして生成します。</li>
          <li>クラスにはパラメーター変動率の設定がある都合で、アドオン「パラメーター増減」は無効化されます。</li>
          <li>アイテム小種別が設定されていないアイテムは装備できません。</li>
        </ul>
      </li>
      <li>
        共通変数/フラグDB
        <ul class="circle">
          <li>ゲームプログラム側からスクリプトのグローバル変数として定義しています。</li>
          <li>セーブデータの読み書きを行うときにだけ、中身の値が参照されます。</li>
        </ul>
      </li>
      <li>IDをキーとして処理する関数群では左端の列をID列とみなすため、ユーザーDBにおいても左端の列が単一値のセルであれば同様にIDとして識別できます。</li>
    </ul>

    <h4>スクリプト</h4>
    <ul class="disc">
      <li>コンパイルエラーが発生したときは、修正された後特定のキーが押されるまでゲームの動作を一時停止します。</li>
      <li>
        ランタイムエラーや内部エラーが発生したときは、ゲームプログラム自体の終了を余儀なくされます。<br>
        システムDBの「制限付きデバッグモード」が無効化されているときは、エラーを無視した処理の続行や、任意コードの実行ができるようになります。<br>
        ランタイムエラー時にエラーを無視した処理の続行や任意コードの実行を行うと、ゲームの動作はより不安定となり、最悪の場合にはタスクマネージャーからの終了を余儀なくされる可能性もありますので原則としてお勧めしません。<br>
      </li>
      <li>ゲームプログラム側が公開する組み込み関数は、厳密な引数チェック（個数と型）が行われます。</li>
      <li>ファイル名の頭に ! が付いたスクリプトは、ユーザーによって動的リロードされる際の対象外となります。</li>
      <li>イベントハンドラーとしてゲームプログラム側で定義された関数名との衝突（再定義）にご注意下さい。</li>
      <li>Squirrelのガベージコレクターは自動的に動作しますが、シーン遷移時に明示的に呼び出されます。</li>
    </ul>

    <h4>サウンド</h4>
    <ul class="disc">
      <li>MIDIはGuruGuruSMFで、その他のサウンドはDXライブラリで再生します。</li>
      <li>音量は 0～255 の間で指定します。サウンドMGRで指定された標準音量が上限となります。</li>
      <li>音程は (-240)～(+240) の間で指定します。１オクターブ下から１オクターブ上まで変化させられます。</li>
      <li>パンは (-255)～(+255) の間で指定します。-255のとき完全左、+255のとき完全右となります。</li>
      <li>GuruGuruSMFはパン指定に対応していないため、MIDIサウンドに限りプログラムからパンを指定することはできません。</li>
      <li>
        一般サウンドの音程
        <ul class="circle">
          <li>サウンドMGRを間接的に利用するサウンドデータクラスの読み込み処理でのみ設定できます。</li>
          <li>音程を変更する場合、読み込み時に適用後のサウンド波形を生成する都合で一定のタイムラグが生じます。</li>
          <li>再生中に音程を変更することはできません。</li>
        </ul>
    </ul>
  </div>
  <hr>

</div><!-- /#mainContainer -->
</div><!-- /#container -->
</body>
</html>
